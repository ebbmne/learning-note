### 函数重载

函数没有重载，如果在定义了两个名字相同的函数，则该名字只属于后定义的函数（相当于重新赋值）

---------------------------------------

### 函数参数

函数中的参数只提供便利，但不是必需的，没有传递值的命名参数将自动被赋予`undefined`值

函数中`arguments `的值永远与对应命名参数的值保持同步，但这并不是说读取这两个值会访问相同的内存空间，它们的内存空间是独立的，但它们的值会同步

`arguments`对象的长度是由传入的参数个数决定的，不是由定义函数时的命名参数的个数决定的

---------------------------------------

### 默认return

函数如果没有return 语句，函数执行完毕后也会返回结果，只是结果为undefined，即默认返回undefined

------------------------------------------

### 变量声明提升

变量声明提升，函数会先扫描整个函数体的语句，把所有申明的变量“提升”到函数顶部

```js
function foo() {
    var x = 'Hello, ' + y;
    console.log(x);
    var y = 'Bob';
}

foo();
```
对于上列代码，解析器看到是
```js
function foo() {
    var y; // 提升变量y的申明，此时y为undefined
    var x = 'Hello, ' + y;
    console.log(x);
    y = 'Bob';
}
```

---------------------------------------------------------

### 函数定义的第三种方法

除了普通函数定义和匿名函数定义外还有一种定义方法——通过Function对象

参数分别为参数列表和函数体字符串

```js
var sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

--------------------------------------------------------------------

### 函数定义提升

普通函数定义会提升，但匿名函数不会，即必须在匿名函数定义语句执行后，才能使用该匿名函数

除了什么时候可以通过变量访问函数这一点区别之外，函数声明与函数表达式的语法其实是等价的
```js
// 不报错，因为解析器会提升普通函数定义
alert(sum(10,10)); 
function sum(num1, num2) {     
  return num1 + num2; 
} 

// 会报错，必须在匿名函数定义语句执行后，才能使用该匿名函数
alert(sum(10,10)); // error
var sum = function(num1, num2) {     
  return num1 + num2; 
}; 
```

----------------------------------------------

### 函数的两个特殊对象

arguments 和 this

-------------------------------------------------

### 函数的两个属性

length属性：表示函数希望接收的命名参数的个数（即定义时形参的个数）

prototype属性：指向函数的原型对象，protoype属性是不可枚举的，因此使用for-in无法发现

-----------------------------------------------------

### 函数的三个方法：都是用于改变函数内 this 的指向

apply(this, [...args]): 执行函数 

call(this, ...args): 执行函数

bind(this): 返回绑定后的新函数，但不执行，一旦绑定就不能再进行修改