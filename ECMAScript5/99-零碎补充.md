#####  ==和===

==比较：它会自动转换数据类型再比较

===比较：它不会自动转换数据类型，如果数据类型不一致，返回false，如果类一致，再比较是否相等

------------------------

##### 检测对象是否具有某一个属性

in操作符: 可能使自身拥有或原型链上对象拥有

hasOwnProperty: 只检查是否自身拥有

--------------------------------

##### 定时器

setInterval(回调函数, 时间毫秒)
* 一直循环执行
* 关闭 Interval 的定时器 : clearInterval(obj)

setTimeout( 回调函数, 时间毫秒)
* 只执行一次
* 关闭 Timeout定时器 : clearTimeout(obj)

定时器只要开和关，没有暂停重启的概念

-----------------------------------

##### switch 表达式

每个 case的值不一定是常量，可以是变量，甚至是表达式

switch 语句在比较值时使用的是全等操作符，因此不会发生类型转换

switch 需要 break，默认贯穿

-----------------------------------

##### with 语句

with 语句的作用是将代码的作用域设置到一个特定的对象中，语法如下
```js
with (obj) {
    ...
    statements;
    ...
} 
```

在 with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询关联对象中是否有同名的属性。如果发现了同名属性，则以关联对象属性的值作为变量的值

例子如下

```js
var qs = location.search.substring(1); 
var hostName = location.hostname; 
var url = location.href; 

// 上面几行代码都包含 location 对象。如果使用 with 语句，可以把上面的代码改写成如下所示

with(location) {     
  var qs = search.substring(1);     
  var hostName = hostname;     
  var url = href; 
} 
```

由于大量使用 with 语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用 with 语句，严格模式下不允许使用 with 语句，否则将视为语法错误

----------------------------------------------

##### for-in 循环

ECMAScript 对象的属性没有顺序，因此通过 for-in 循环输出的属性名的顺序是不可预测的。 即所有属性都会被返回一次，但返回的先后次序可能会因浏览器而异

在使用for-in循环时，返回的是所有能够通过对象访问的、可枚举的属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性

屏蔽了原型中不可枚举属性的实例属性也会在for-in循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的

------------------------------------------------------

##### 检测类型

使用 typeof 或 instanceof 操作符

typeof 对于对象判断用处不大，只能识别 function

instanceof 根据原型链判断

instanceof 操作符检测基本类型的值，则该操作符始终会返回 false，因为基本类型不是对象

--------------------------------------------

##### 不能给基本类型的值添加属性

这样做不会导致任何错误，但是无效，因为基本类型不是对象

------------------------------------------------------

##### 垃圾回收

JavaScript 具有自动垃圾收集机制，即执行环境会负责管理代码执行过程中使用的内存

垃圾收集机制的原理——标记清除

> JavaScript 中最常用的垃圾收集方式是标记清除。当变量进入环境（例如，在函数中声明一个变量）时，就将这个变量标记为“进入环境”。
>
> 从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”，垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记（当然，可以使用任何标记方式）。
>
> 然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记，而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后，垃圾收集器 完成内存清除工作，销毁那些带标记的值并回收它们所占用的内存空间。 

垃圾收集机制的原理——引用计数

> 另一种不太常见的垃圾收集策略叫做引用计数，引用计数的含义是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型值赋给该变量时，则这个值的引用次数就是1。 
>
> 如果同一个值又被赋给另一个变量，则该值的引用次数加1。相反，如果包含对这个值引用的变量又取 得了另外一个值，则这个值的引用次数减 1。
>
> 当这个值的引用次数变成 0时，则说明没有办法再访问这 个值了，因而就可以将其占用的内存空间回收回来。这样，当垃圾收集器下次再运行时，它就会释放那 些引用次数为零的值所占用的内存。
>
> 一个严重的问题：循环引用
> 循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用
> ```js
> function problem() {     
> var objectA = new Object();     
> var objectB = new Object(); 
> objectA.someOtherObject = objectB;     
> objectB.anotherObject = objectA; 
> } 
> ```

-----------------------------------------------------------

##### 解除引用

一旦数据不再有用，最好通过将其值设置为null来释放其引用——这个做法叫做解除引用

这一做法适用于大多数全局变量和全局对象的属性，局部变量会它们离开执行环境时自动被解除引用