### 事件基础

#### 事件介绍

事件是指发生在DOM元素上的事情

事件是触发-响应机制，即分为事件的触发和事件的响应

#### 事件三要素

事件源：被绑定事件的DOM元素对象

事件类型：即事件触发的方式

事件处理程序：事件响应的函数，即回调函数

#### 使用事件的步骤

获取事件源

注册事件（绑定事件）

添加事件处理程序

------------------------------------

### 注册事件

给元素添加事件，称为注册事件或者绑定事件

#### 传统注册方式

用法：直接给元素添加"on"+事件类型和相应的事件处理函数
```js
btn.onclick = function() {}
```

特点：注册事件的唯一性，即同一个元素的同一事件只能设置一个处理函数，最后设置的处理函数会覆盖之前的处理函数

#### 方法监听注册方式

特点：同一个元素的同一事件可以设置多个处理函数，不会被覆盖

用法一：addEventListener(type, callback [, useCapture])

| 参数       | 说明                                                         |
| ---------- | ------------------------------------------------------------ |
| type       | 事件类型，注意不加on，比如click, mouseover                   |
| callback   | 事件处理函数                                                 |
| useCapture | 可选参数，是一个布尔值，默认是false，是否选择在捕获阶段进行检查 |

用法二：attachEvent(type, callback)

该方法只支持IE6,7,8没啥用

| 参数     | 说明                                         |
| -------- | -------------------------------------------- |
| type     | 事件类型，注意加on，比如onclick, onmouseover |
| callback | 事件处理函数                                 |

---------------------------------------------------

### 解绑事件

#### 传统解绑方式

将事件处理函数置为null即可 
```js
btn.onclick = null;
```

#### 方法解绑方式

方法一：removeEventListener(type, callback [, useCapture])

| 参数       | 说明                                       |
| ---------- | ------------------------------------------ |
| 事件类型   | 事件类型，注意不加on，比如click, mouseover |
| callback   | 事件处理函数                               |
| useCapture | 可选参数，是一个布尔值，默认是false        |

方法二：detachEvent(type, callback)

该方法只支持IE6,7,8没啥用

| 参数     | 说明                                         |
| -------- | -------------------------------------------- |
| type     | 事件类型，注意加on，比如onclick, onmouseover |
| callback | 事件处理函数                                 |

-----------------------------------------------------

### DOM事件流

#### DOM事件流定义

触发事件时，事件会在元素节点之间按照特定的顺序进行传播，这个传播过程就是DOM事件流

#### DOM事件流顺序

事件传播顺序可以划分为3个部分：捕获阶段 -> 目标元素 -> 冒泡阶段

捕获阶段：事件由DOM最顶层节点开始，逐级向下传播到目标元素的过程

目标元素：执行事件处理函数

冒泡阶段：事件开始由目标元素开始，逐级向上传播到DOM最顶层节点的过程

![](./images/dom_event_stream.png)

#### DOM事件流特点

事件在传播过程中，会检查经过的当前节点有没有绑定该事件的处理函数，如果有则调用该处理函数，如果没有则按顺序将事件传递给下一个元素

这样的检查和调用只能选择在捕获阶段和冒泡阶段的其中一个阶段进行
* 如果选定在冒泡阶段进行事件检查和调用，则事件在捕获阶段不会被执行
* 如果选定在捕获阶段进行事件检查和调用，则事件在冒泡阶段不会被执行

#### 选定进行检查调用的阶段

对于使用传统绑定和attachEvent绑定的事件，只能选择在冒泡阶段进行检查和调用，而不能选择捕获阶段检查和调用

对于使用addEventListener绑定的事件可以选择在捕获阶段或者冒泡阶段进行检查和调用
*  addEventListener(type, callback [, useCapture])
*  第三个参数为一个布尔值，用于判断是否在捕获阶段进行检查调用

#### 没有捕获阶段和冒泡阶段的事件

onblur, onfoucs, onmouseenter, onmouseleave

--------------------------------------------------------------------------------

### 事件对象

#### 事件对象定义

当触发事件后，在执行事件处理函数时，系统会自动将该事件的相关数据和信息封装到一个对象中，该对象称为事件对象

#### 事件对象作用

系统会自动将事件对象作为参数传递给事件处理函数，从而让事件处理函数根据事件对象来进行相应的事件处理

#### 获取事件对象
非IE6-8，事件对象会作为参数自动传给事件处理函数

IE6-8，事件对象会传给全局window.event变量
```js
function (ev) {
    let oEvent = ev || window.event;
    // ev 非 IE6-8
    // event IE6-8 
} 
```

#### 通用事件对象属性和方法

| 事件属性和方法      | 说明                                           | 是否符合标准          |
| ------------------- | ---------------------------------------------- | --------------------- |
| e.type              | 返回事件的类型【不带on，比如click, mouseover】 | 符合                  |
| e.target            | 触发事件的对象                                 | 符合                  |
| e.srcElement        | 触发事件的对象                                 | 不符合，为了兼容IE6-8 |
| e.stopPropagation() | 阻止事件冒泡                                   | 符合                  |
| e.cancelBubble      | 阻止事件冒泡                                   | 不符合，为了兼容IE6-8 |
| e.preventDefault()  | 阻止事件默认行为【比如链接跳转，表单提交】     | 符合                  |
| e.returnValue       | 阻止事件默认行为                               | 不符合，为了兼容IE6-8 |

##### 阻止默认行为的第二种方法

除了e.preventDefault()和e.returnValue之外还有一种方法，直接在函数内写 `return false`，特点：只能写在函数的最后

##### e.target和this的区别

e.target是指触发事件的元素对象，而this是指绑定事件的元素对象

```html
<ul>
    <li>1</li>
    <li>2</li>
    <li>3</li>
</ul>
<script>
    document.querySelector("ul").onclick = function(e) {
        console.log(this);
        console.log(e);
    }
</script>

当点击li时，e.target指向所点击的li元素，this指向ul元素
当点击ul时，e.target指向ul元素，this指向ul元素
```

#### 鼠标事件和事件对象属性

##### 鼠标事件

| 事件方法    | 事件说明         |
| ----------- | ---------------- |
| onclick     | 鼠标点击         |
| onmousedown | 鼠标按住左键     |
| onmouseup   | 鼠标松开按键     |
| onmousemove | 鼠标移动         |
| onmouseover | 鼠标移入         |
| onmouseout  | 鼠标移出         |
| onfocus     | 获取鼠标焦点     |
| onblur      | 失去鼠标焦点     |
| contextmenu | 点击右键弹出菜单 |
| selectstart | 鼠标开始选中     |

mouseenter和mousemove区别

* mouseover经过自身盒子会触发，经过子盒子也会触发，因为mouseover会冒泡
* mouseenter只有经过自身才会触发，因为mouseenter不会冒泡
* mouseleave与mouseenter搭配，也不会冒泡
* mouseout与mouseover搭配，也会冒泡

##### 鼠标事件对象属性

| 属性      | 属性说明                            |
| --------- | ----------------------------------- |
| e.clientX | 鼠标相对于浏览器可视区的X坐标       |
| e.clientY | 鼠标相对于浏览器可视区的Y坐标       |
| e.screenX | 鼠标相对于电脑屏幕的X坐标           |
| e.screenY | 鼠标相对于电脑屏幕的Y坐标           |
| e.pageX   | 鼠标相对于文档页面的X坐标【最常用】 |
| e.pageY   | 鼠标相对于文档页面的Y坐标【最常用】 |

#### 键盘事件和事件对象属性

##### 键盘事件

| 事件       | 事件说明 | 注意                                                      |
| ---------- | -------- | --------------------------------------------------------- |
| onkeydown  | 键盘按下 | 不区分字母大小写                                          |
| onkeyup    | 键盘弹起 | 不区分字母大小写                                          |
| onkeypress | 键盘按下 | 区分字母大小写<br />不识别功能键，如ctrl、shift、箭头等等 |
三个事件的执行顺序：keydown --> keypress --> keyup

##### 键盘事件对象

| 属性       | 属性说明   |
| ---------- | ---------- |
| e.keyCode  | 按键的code |
| e.ctrlKey  | ctrl键     |
| e.altKey   | alt键      |
| e.shiftKey | shift键    |

--------------------------------------------------------------------------------

### 事件委托

#### 事件委托是什么

事件委托也称为事件代理，它就是把一个元素的事件委托给另一个元素进行绑定和处理

#### 事件委托原理

不用给每个子节点都单独绑定事件，而是为其父节点绑定事件，利用事件默认的冒泡行为来间接将事件处理函数作用于子节点

配合e.target使用，e.target始终指向触发事件的元素

#### 事件委托作用

只需要绑定一次事件，就可以让多个节点能够触发该事件，故有下列优点

* 大量节省内存，因为不用每个节点都单独设置一个事件处理函数
* 提高可维护性，只要修改父节点的事件处理函数，则所有子节点都能修改其事件处理行为

--------------------------------------------

### 事件循环(event loop)

#### JS单线程的问题

JS是单线程语言，也就是说同一时间只能做一件事，原因是——JS是为了处理页面用户的交互，以及操作DOM而诞生的，这些操作并不能同时进行

因为是单线程，所以任务需要排队，一个一个地执行，这导致一个问题，如果JS执行的时间过长，则会导致程序阻塞的感觉

为了解决这个问题，利用多核CPU的计算能力，HTML5提出了Web Worker标准，允许JS脚本创建多个线程，于是JS中出现了同步和异步

* 同步：一个一个逐个执行
* 异步：在做一件事情时，因为这件事情非常耗费时间，所以在做这件事情的同时，可以去处理其他的事情

#### JS任务分类

任务分为同步任务和异步任务

同步任务：同步任务都在主线程上执行，形成一个执行栈

异步任务：异步任务是通过回调函数执行的，异步任务又可以细分为宏任务和微任务

| 异步任务分类 | 常见异步任务             |
| ------------ | ------------------------ |
| 宏任务       | DOM事件，定时器，XMLHttp |
| 微任务       | Promise                  |

#### JS执行机制

先执行执行栈中的同步任务 --> 遇到异步任务则由其他线程执行 --> 回调函数加入到任务队列 --> 执行栈中的所有同步任务执行完毕后，系统就会次序读取任务队列中的异步任务 --> 执行完全部微任务后 --> 执行一个宏任务 --> 进入下一轮循环

#### 事件循环示例图

![](./images/event_loop.png)