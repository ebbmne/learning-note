### 泛型方法

泛型方法是在使用时，能够自定义其类型的方法

定义语法

```typescript
function 函数名<T,S,...>(参数1: T, 参数2: S, ...): T {}
```

例子

```typescript
function getNumber<T>(num: T): T {}
function getNumberArray<T>(num: T[]): T[] {}
```

<br/>

### 泛型类

泛型类是在使用时，能够自定义其类型的类

定义语法

```typescript
class 类名<T,S, ...> {
	成员属性: T;
    方法(参数: S) {}
}
```

例子

```typescript
class Add<T> {
    zeroValue: T;
    add: (x: T, y: T) => {}
}
```

<br/>

### 泛型约束

规定传入的类型，必须实现某种接口

定义语法

```typescript
function 函数名<T extends 接口>(参数: T): T {}
```

例子

```typescript
interface LengthWise {
    length: number;
}

function getNum<T extends LengthWise>(num: T): T {
    console.log(num.length);
}
```

<br/>

### 约束泛型参数必须有某个属性

在使用泛型方法时，我们有时需要确认该类型的对象上具有某个属性，这时可以使用`keyof`来检查

`keyof T`产生的类型是T的属性名称字符串字面量类型构成的联合类型

```typescript
interface Itest {
    WebName: string;
    age: number;
    address: string;
}

type ant = keyof Itest; // type ant = "webName" | "age" | "address"
```

判断T是否拥有属性K

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K) {
    return obj[key];
}

let person = {name: "typescript", age: 20, gender: "male"};

getProperty(person, 'age'); // ok
getProperty(person, 'hobby'); // error
```

